# 练习1：理解内核启动中的程序入口操作
## 总体背景：内核启动流程

在 RISC-V 或类似体系结构中，**内核启动流程（boot process）** 通常如下：

1. **机器上电 → Bootloader（如 OpenSBI）运行**

   * 初始化最基本的硬件（MMU、页表、栈、内存布局）。
   * 把控制权转交给操作系统内核的入口点 `kern_entry`。

2. **进入 `kern_entry` 汇编函数**

   * 建立内核自己的运行栈。
   * 跳转到 C 语言的内核初始化函数 `kern_init`。

3. **在 `kern_init()` 中**

   * 初始化内存管理、异常处理、进程调度、文件系统等。

---

## 逐行分析 `entry.S`

### 源代码回顾

```asm
#include <mmu.h>             # 包含内存管理单元相关常量（如页大小 PGSHIFT）
#include <memlayout.h>       # 包含系统内存布局常量（如内核栈大小 KSTACKSIZE）

    #-----------------------------------------------------------
    # .text 段：可执行代码区
    #-----------------------------------------------------------
    .section .text,"ax",%progbits
    .globl kern_entry         # 声明全局符号，作为内核启动入口
kern_entry:
    #-----------------------------------------------------------
    # 1️⃣ 初始化栈指针（sp）
    #-----------------------------------------------------------
    # la sp, bootstacktop 的含义：
    #   将 bootstacktop 的地址加载到 sp 寄存器。
    #   bootstacktop 是内核栈的最高地址（即栈顶），
    #   栈从高地址向低地址增长。
    #   这一步确保 CPU 进入 C 代码前有合法的栈空间。
    la sp, bootstacktop

    #-----------------------------------------------------------
    # 2️⃣ 跳转到内核 C 语言入口函数 kern_init
    #-----------------------------------------------------------
    # tail kern_init 的作用：
    #   直接跳转到 C 函数 kern_init，
    #   并不返回（tail 等价于 j 指令的尾调用优化形式）。
    #   从此处开始，执行内核初始化的 C 语言逻辑。
    tail kern_init


    #-----------------------------------------------------------
    # .data 段：定义内核栈空间
    #-----------------------------------------------------------
.section .data
    # .align PGSHIFT
    #   按照 2^PGSHIFT (通常为 4096 字节) 对齐，
    #   确保栈在页边界上开始，方便页表映射与管理。
    .align PGSHIFT

    .global bootstack         # 导出符号 bootstack（栈底）
bootstack:
    # .space KSTACKSIZE
    #   预留一段连续空间作为内核启动时使用的栈，
    #   大小为 KSTACKSIZE（一般为 8KB 或 16KB）。
    .space KSTACKSIZE

    .global bootstacktop      # 导出符号 bootstacktop（栈顶）
bootstacktop:
    # bootstacktop 紧跟在 bootstack 之后，
    # 表示栈的最高地址，也就是初始 sp 指向的位置。

    #-----------------------------------------------------------
    # 栈内存布局示意（栈从高向低增长）：
    #
    #   高地址 ↑
    #           +-------------------+ ← bootstacktop (sp 初值)
    #           |                   |
    #           |    栈空间          |
    #           |                   |
    #           +-------------------+ ← bootstack
    #   低地址 ↓
    #-----------------------------------------------------------

````

---

### 指令 1：`la sp, bootstacktop`

### 含义：

`la` 是 “load address” 指令，用来将符号（即变量或标签）的**地址**加载到寄存器。
所以：

```asm
la sp, bootstacktop
```

的作用是：
把标签 `bootstacktop` 的地址加载到 **栈指针寄存器 sp**（stack pointer）中。

### 这行代码完成的操作：

* 将内核启动栈（`bootstack`）的栈顶地址设置为当前栈指针。
* 换句话说，**为内核的第一段执行代码分配了一段可用的栈空间**。

### 背景说明：

在内核刚启动时（从 bootloader 跳进来的时候），CPU 的寄存器 `sp` 可能是未定义的或是 Bootloader 的临时栈。
所以内核第一件事必须是：

> 自己建立一块新的安全的栈空间。

而这块栈空间就是在 `.data` 段定义的：

```asm
bootstack:
    .space KSTACKSIZE        # 分配一段连续空间作为内核栈
bootstacktop:
```

假设：

* `KSTACKSIZE = 8KB`
* 那么 `bootstack` 是底部地址，`bootstacktop` 是栈顶。

由于栈在 RISC-V 是 **向低地址增长** 的，所以我们让 `sp` 指向“栈顶”（高地址）。

### **总结：**

| 指令                    | 操作              | 目的                                  |
| --------------------- | --------------- | ----------------------------------- |
| `la sp, bootstacktop` | 将内核栈顶地址加载到 `sp` | 为内核代码设置运行栈，保证后续函数调用、保存寄存器等操作有安全的栈空间 |

---

### 指令 2：`tail kern_init`

### 含义：

`tail` 是 GNU 汇编器（以及 RISC-V）中对：

```asm
j kern_init
```

或

```asm
jal kern_init
ret
```

的**优化伪指令**。
它的含义是：**无返回的跳转（尾调用）到另一个函数**。

### 这行代码完成的操作：

直接跳转到 C 函数 `kern_init`，并且：

* 不再保留当前 `kern_entry` 的返回地址；
* 不占用额外栈空间（节省指令和栈）。

这意味着：

> 从此刻开始，内核的执行正式进入 `kern_init()` 函数，`kern_entry` 不会再回来。

---

### **总结：**

| 指令               | 操作                    | 目的                          |
| ---------------- | --------------------- | --------------------------- |
| `tail kern_init` | 无返回地跳转到 `kern_init()` | 切换执行流到 C 语言内核初始化函数，开始系统级初始化 |

---

## 整体总结

| 阶段 | 汇编语句                  | 功能                | 目的                |
| -- | --------------------- | ----------------- | ----------------- |
| 1  | `la sp, bootstacktop` | 设置栈指针 `sp` 指向内核栈顶 | 为内核提供安全可用的运行栈     |
| 2  | `tail kern_init`      | 无返回跳转到内核初始化函数     | 开始执行 C 语言的系统初始化逻辑 |

---

## 扩展理解

在操作系统的启动过程中，**汇编部分只负责硬件态到内核 C 环境的“桥梁”工作**：

* 建立栈
* 设置全局寄存器（如 sp、gp）
* 初始化内存映射或页表（若需要）
* 跳转到 `kern_init()` 进入 C 世界

所以这一小段汇编虽然短，却是 **内核从“裸机”到“高层初始化”的关键过渡点**。

# 练习 2：GDB 跟踪 RISC-V 启动流程
目标：跟踪从复位地址 0x1000 开始，直到内核第一条指令（`kern_entry @ 0x80200000`）执行。

## 1 调试准备
```bash
make clean && make          # 生成 bin/kernel ucore.img
make debug                  # QEMU (-gdb tcp::1234 -S) 挂起等待 GDB
make gdb                    # 连接 GDB 会停在 0x1000
```

## 2 跟踪步骤
```gdb
# 启动后 PC=0x1000 (复位向量)
(gdb) x/10i 0x1000           # 观察固件早期指令（OpenSBI）
(gdb) watch *0x80200000      # 观察内核镜像写入瞬间
(gdb) b *0x80200000          # 在内核入口物理地址断点
(gdb) c                      # 继续执行，直到固件完成加载并跳转
```
![硬件初始化和固件启动](imgs/1.1.png)
![OpenSBI 初始化与内核加载](imgs/1.2.png)
![内核启动执行](imgs/1.3.png)
![跳转到entry.S ](imgs/1.4.png)
![调用kern_init()](imgs/1.5.png)
## 3 观察结果摘要
| 阶段 | 观察到的地址/现象 | 说明 |
|------|------------------|------|
| 复位 | PC=0x0000000000001000 | QEMU virt 复位向量；执行固件 ROM/OpenSBI 指令 |
| 固件初始化 | 多条访问/设置 CSR/内存的指令 | 建立最小执行环境，准备加载内核 |
| 内核加载 | `watch *0x80200000` 触发  | 固件将 `ucore.img` 拷贝到 DRAM 基址 + 偏移 |
| 跳转内核 | 断点命中 0x80200000 | 开始执行 `kern_entry` 第一条指令 `la sp, bootstacktop` |
| 进入 C | 单步执行 `tail kern_init` 后 PC 到 `kern_init` | 进入 C 初始化逻辑，清 BSS，打印信息 |
| 死循环 | 停在 `while(1)` | 等待后续实验扩展 |

## 4 回答问题
1) RISC-V 硬件加电后最初执行的几条指令位于地址：`0x1000`（QEMU virt 的默认复位向量）。
2) 这些早期指令（固件/OpenSBI）主要功能：设置特权级初始状态、建立必要的机器态环境、解析/准备内核镜像（或在本实验场景由 QEMU loader 直接放置）、最终跳转到内核入口地址 0x80200000。
3) 验证方法：在 GDB 中观察 PC 初值；设置 `b *0x80200000`；可用 `watch *0x80200000` 捕获写入；断点命中后查看反汇编与符号匹配。


